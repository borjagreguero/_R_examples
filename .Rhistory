P = 0.1
Q = 1-P
e = 0.02
term1 = N * k^2 * P * Q
term2 = e^2 * (N-1) + k^2 * P * Q
n = term1/term2
n
138/5
864-5
864/5
864/5/20
devtools::install_github('jcizel/FredR')
api.key = 'aace5b02f7165b7c56a926589dadbfb9'  # substitute ... with your API key
# Next, you need to initialize FredR:
fred <- FredR(api.key)
library(FredR)
api.key = 'aace5b02f7165b7c56a926589dadbfb9'  # substitute ... with your API key
# Next, you need to initialize FredR:
fred <- FredR(api.key)
fred
str(fred,1)
gdp.series <- fred$series.search("GDP")
head(gdp.series)
head(gdp.series$title)
str(gdp.series$title)
(gdp.series$title)
View(gdp.series)
View(gdp.series)
GDP = gdp.series[2,]
GDP
GDP <- fred$series.observations(series_id = 'GDP')
GDP
qplot(GDP$value)
library(pipeR)
library(dplyr)
library(pipeR)
library(dplyr)
qplot(GDP$value)
library(ggplot2)
qplot(GDP$value)
library(FredR)
GDP$value
plot(GDP$value)
plot(GDP$value,type = 2)
plot(GDP$value,type = 20)
?plot
plot(GDP$value,type = "l")
plot(GDP$value,type = "l",xlab = "time",ylim = "GDP (bill $)")
plot(GDP$value,type = "l",xlab = "time",ylim = "GDP (bill $)")
plot(GDP$value,type = "l",xlab = "time",ylab = "GDP (bill $)")
grid
plot(x = GDP$date, GDP$value,type = "l",xlab = "time",ylab = "GDP (bill $)")
plot(x = GDP$date, Y=GDP$value,type = "l",xlab = "time",ylab = "GDP (bill $)")
plot(x = GDP$date, y=GDP$value,type = "l",xlab = "time",ylab = "GDP (bill $)")
GDP$date
plot(x = as.numeric(GDP$date), y=GDP$value,type = "l",xlab = "time",ylab = "GDP (bill $)")
plot(x = as.Date(GDP$date), y=GDP$value,type = "l",xlab = "time",ylab = "GDP (bill $)")
install.packages("FREDR")
install.packages(c("quant", "mod"))
library(quantmod)
install.packages("quantmod")
library(quantmod)
getSymbols.FRED
setDefaults(getSymbols,src='FRED')
getSymbols('CPIAUCNS')
install.packages("Quandl")
library(Quandl)
mydata = Quandl("FRED/GDP")
mydata = Quandl("FRED/GDP")
mydata
Quandl("FRED/GDP", collapse="annual")
Quandl("FRED/GDP", transform="rdiff")
system("java -version")
system("java -version")
system("java -version")
install.packages("caret", dependencies = c("Depends", "Suggests"))
library("caret")
#Loading training data
train<-read.csv("train_u6lujuX_CVtuZ9i.csv",stringsAsFactors = T)
library("caret")
install.packages("caret")
library("caret")
#Loading training data
train<-read.csv("train_u6lujuX_CVtuZ9i.csv",stringsAsFactors = T)
setwd("~/bgr/MOOC/_R/_R_examples")
train<-read.csv("./data/train_u6lujuX_CVtuZ9i.csv",stringsAsFactors = T)
train<-read.csv("./data/train_u6lujuX_CVtuZ9i.csv",stringsAsFactors = T)
library("caret")
train<-read.csv("./data/train_u6lujuX_CVtuZ9i.csv",stringsAsFactors = T)
str(train)
sum(is.na(train))
# ?preProcess
?preProcess
preProcValues <- preProcess(train, method = c("knnImpute","center","scale"))
preProcValues
library('RANN')
train_processed <- predict(preProcValues, train)
sum(is.na(train_processed))
train_processed
train_processed$Loan_Status<-ifelse(train_processed$Loan_Status=='N',0,1)
id<-train_processed$Loan_ID
id
train_processed
head(train_processed)
train_processed$Loan_Status<-ifelse(train_processed$Loan_Status=='N',0,1)
train_processed <- predict(preProcValues, train)
sum(is.na(train_processed))
head(train_processed)
train_processed$Loan_Status<-ifelse(train_processed$Loan_Status=='N',0,1)
id<-train_processed$Loan_ID
train_processed$Loan_ID<-NULL
head(train_processed)
train_processed <- predict(preProcValues, train)
sum(is.na(train_processed))
head(train_processed)
train_processed$Loan_Status<-ifelse(train_processed$Loan_Status=='N',0,1)
id<-train_processed$Loan_ID
train_processed$Loan_ID<-NULL
str(train_processed)
?dummyVars
dmy <- dummyVars(" ~ .", data = train_processed,fullRank = T)
dmy
train_transformed <- data.frame(predict(dmy, newdata = train_processed))
#Checking the structure of transformed train file
str(train_transformed)
str(train_processed)
str(train_transformed)
train_transformed$Loan_Status<-as.factor(train_transformed$Loan_Status)
str(train_transformed)
index <- createDataPartition(train_transformed$Loan_Status, p=0.75, list=FALSE)
index
trainSet <- train_transformed[ index,]
trainSet <- train_transformed[ index,]
testSet <- train_transformed[-index,]
str(trainSet)
control <- rfeControl(functions = rfFuncs,
method = "repeatedcv",
repeats = 3,
verbose = FALSE)
outcomeName<-'Loan_Status'
control
?rfeControl
names(trainSet)
predictors<-names(trainSet)[!names(trainSet) %in% outcomeName]
predictors
Loan_Pred_Profile <- rfe(trainSet[,predictors], trainSet[,outcomeName],
rfeControl = control)
Loan_Pred_Profile
predictors<-c("Credit_History", "LoanAmount", "Loan_Amount_Term", "ApplicantIncome", "CoapplicantIncome")
names(getModelInfo())
model_gbm<-train(trainSet[,predictors],trainSet[,outcomeName],method='gbm')
model_rf<-train(trainSet[,predictors],trainSet[,outcomeName],method='rf')
model_nnet<-train(trainSet[,predictors],trainSet[,outcomeName],method='nnet')
model_glm<-train(trainSet[,predictors],trainSet[,outcomeName],method='glm')
fitControl <- trainControl(
method = "repeatedcv",
number = 5,
repeats = 5)
modelLookup(model='gbm')
grid <- expand.grid(n.trees=c(10,20,50,100,500,1000),shrinkage=c(0.01,0.05,0.1,0.5),n.minobsinnode = c(3,5,10),interaction.depth=c(1,5,10))
grid
modelLookup(model='gbm')
model_gbm<-train(trainSet[,predictors],trainSet[,outcomeName],method='gbm',
trControl=fitControl,tuneGrid=grid)
print(model_gbm)
plot(model_gbm)
model_gbm<-train(trainSet[,predictors],trainSet[,outcomeName],
method='gbm',
trControl=fitControl,tuneLength=10)
print(model_gbm)
plot(model_gbm)
model_gbm<-train(trainSet[,predictors],trainSet[,outcomeName],
method='gbm',
trControl=fitControl,tuneLength=10)
print(model_gbm)
plot(model_gbm)
varImp(object=model_gbm)
#Plotting Varianle importance for GBM
plot(varImp(object=model_gbm),main="GBM - Variable Importance")
varImp(object=model_rf)
varImp(object=model_rf)
plot(varImp(object=model_rf),main="RF - Variable Importance")
varImp(object=model_gbm)
varImp(object=model_rf)
varImp(object=model_nnet)
varImp(object=model_glm)
predictions<-predict.train(object=model_gbm,testSet[,predictors],type="raw")
table(predictions)
confusionMatrix(predictions,testSet[,outcomeName])
library('Metrics')
library('randomForest')
library('ggplot2')
library('ggthemes')
library('dplyr')
install.packages("Metrics")
set.seed(101)
#loading dataset
data<-read.csv("./data/stock_data.csv",stringsAsFactors= T)
dim(data)
data$Y<-as.factor(data$Y)
data$Time<-NULL
head(data)
str(data)
summary(data)
train<-data[1:2000,]
test<-data[2001:3000,]
model_rf<-randomForest(Y ~ ., data = train)
preds<-predict(model_rf,test[,-101])
table(preds)
auc(preds,test$Y)
library('Metrics')
auc(preds,test$Y)
library("Metrics")
auc(preds,test$Y)
importance(model_rf)
importance(model_rf)
plot(importance(model_rf),main="NNET - Variable Importance")
importance(model_rf)
= 1, shrinkage = 0.1 and n.minobsinnode = 10.
model_rf<-randomForest(Y ~ X55+X11+X15+X64+X30
+X37+X58+X2+X7+X89
+X31+X66+X40+X12+X90
+X29+X98+X24+X75+X56,
data = train)
preds<-predict(model_rf,test[,-101])
table(preds)
auc(preds,test$Y)
plot(varImp(object=model_rf),main="Variable Importance")
varImp(object=model_rf)
varImp(object=model_rf)
varImp(object=model_nnet)
model_rf
data(Europe)
library(tmap)
install.packages("tmap")
data(Europe)
library(tmap)
data(land)
data(World)
tm_shape(land, ylim = c(-88,88), relative=FALSE) +
# tm_raster("cover_cls", palette = pal8, title="Global Land Cover", legend.hist=TRUE, legend.hist.z=0) +
tm_shape(World) +
tm_borders() +
tm_format_World(inner.margins=0)
_shape(land, ylim = c(-88,88), relative=FALSE) +
tm_raster("cover_cls", palette = pal8, title="Global Land Cover", legend.hist=TRUE, legend.hist.z=0) +
tm_shape(World) +
tm_borders() +
tm_format_World(inner.margins=0) +
tm_legend(text.size=1,
title.size=1.2,
position = c("left","bottom"),
bg.color = "white",
bg.alpha=.2,
frame="gray50",
height=.6,
hist.width=.2,
hist.height=.2,
hist.bg.color="gray60",
hist.bg.alpha=.5)
tm_shape(land, ylim = c(-88,88), relative=FALSE) +
tm_raster("cover_cls", palette = pal8, title="Global Land Cover", legend.hist=TRUE, legend.hist.z=0) +
tm_shape(World) +
tm_borders() +
tm_format_World(inner.margins=0) +
tm_legend(text.size=1,
title.size=1.2,
position = c("left","bottom"),
bg.color = "white",
bg.alpha=.2,
frame="gray50",
height=.6,
hist.width=.2,
hist.height=.2,
hist.bg.color="gray60",
hist.bg.alpha=.5)
pal8 <- c("#33A02C", "#B2DF8A", "#FDBF6F", "#1F78B4", "#999999", "#E31A1C", "#E6E6E6", "#A6CEE3")
tm_shape(land, ylim = c(-88,88), relative=FALSE) +
tm_raster("cover_cls", palette = pal8, title="Global Land Cover", legend.hist=TRUE, legend.hist.z=0) +
tm_shape(World) +
tm_borders() +
tm_format_World(inner.margins=0) +
tm_legend(text.size=1,
title.size=1.2,
position = c("left","bottom"),
bg.color = "white",
bg.alpha=.2,
frame="gray50",
height=.6,
hist.width=.2,
hist.height=.2,
hist.bg.color="gray60",
hist.bg.alpha=.5)
qtm(Europe, style="natural", title="Natural style") # equivalent to: qtm(Europe) + tm_style_natural(title="Natural style")
data("Europe")
qtm(Europe, style="natural", title="Natural style") # equivalent to: qtm(Europe) + tm_style_natural(title="Natural style")
qtm(Europe, style="cobalt", title="Cobalt style") # equivalent to: qtm(Europe) + tm_style_cobalt(title="Cobalt style")
qtm(Europe, fill="economy", title=paste("Style:", tmap_style()))
## current tmap style is "white
Europe
head(Europe)
str(Europe)
summary(Europe)
head(Europe@data)
current_style <- tmap_style("col_blind")
## tmap style set to "col_blind"
# make a categorical map
qtm(Europe, fill="economy", title=paste("Style:", tmap_style()))
tmap_style(current_style)
(tm <- qtm(World) +
tm_layout(outer.margins=c(.05,0,.05,0),
inner.margins=c(0,0,.02,0), asp=0))
tm + tm_layout(design.mode=TRUE)
tm_shape(land, projection="eck4") +
tm_raster("elevation", breaks=c(-Inf, 250, 500, 1000, 1500, 2000, 2500, 3000, 4000, Inf),
palette = terrain.colors(9), title="Elevation", auto.palette.mapping=FALSE) +
tm_shape(World) +
tm_borders("grey20") +
tm_grid(projection="longlat", labels.size = .5) +
tm_text("name", size="AREA") +
tm_compass(position = c(.65, .15), color.light = "grey90") +
tm_credits("Eckert IV projection", position = c(.85, 0)) +
tm_style_classic(inner.margins=c(.04,.03, .02, .01), legend.position = c("left", "bottom"),
legend.frame = TRUE, bg.color="lightblue", legend.bg.color="lightblue",
earth.boundary = TRUE, space.color="grey90")
tm <- tm_shape(World) +
tm_fill("well_being", id="name", title="Well-being") +
tm_format_World()
tm_shape(Europe[Europe$name=="Austria", ]) +
tm_polygons()
tm_shape(World, bbox = "India") +
tm_polygons("MAP_COLORS", palette="Pastel2") +
tm_shape(metro) +
tm_bubbles("pop2010", title.size = "Population") +
tm_text("name", size = "pop2010", legend.size.show = FALSE, root=8, size.lowerbound = .7, auto.placement = TRUE)
tm_shape(World, bbox = "India") +
tm_polygons("MAP_COLORS", palette="Pastel2") +
tm_shape(metro) +
tm_bubbles("pop2010", title.size = "Population") +
tm_text("name", size = "pop2010",
legend.size.show = FALSE,
root=8, size.lowerbound = .7, auto.placement = TRUE)
tm_shape(World, bbox = "India") +
tm_polygons("MAP_COLORS", palette="Pastel2") +
tm_shape(metro) +
tm_bubbles("pop2010", title.size = "Population") +
tm_text("name", size = "pop2010",
legend.size.show = FALSE,
root=8, size.lowerbound = .7, auto.placement = TRUE)
tm_shape(World, bbox = "India") +
tm_polygons("MAP_COLORS", palette="Pastel2")
qtm(Europe)
qtm(Europe, fill="well_being", text="iso_a3", text.size="AREA", format="Europe", style="gray",
text.root=5, fill.title="Well-Being Index", fill.textNA="Non-European countries")
tm_shape(Europe) +
tm_polygons("well_being", textNA="Non-European countries", title="Well-Being Index") +
tm_text("iso_a3", size="AREA", root=5) +
tm_format_Europe() +
tm_style_grey()
tm_shape(land) +
tm_raster("trees", breaks=seq(0, 100, by=20), legend.show = FALSE) +
tm_shape(Europe, is.master = TRUE) +
tm_borders() +
tm_shape(rivers) +
tm_lines(lwd="strokelwd", scale=5, legend.lwd.show = FALSE) +
tm_shape(metro) +
tm_bubbles("pop2010", "red", border.col = "black", border.lwd=1,
size.lim = c(0, 11e6), sizes.legend = c(1e6, 2e6, 4e6, 6e6, 10e6),
title.size="Metropolitan Population") +
tm_text("name", size="pop2010", scale=1, root=4, size.lowerbound = .6,
bg.color="white", bg.alpha = .75,
auto.placement = 1, legend.size.show = FALSE) +
tm_format_Europe() +
tm_style_natural()
tm_shape(Europe) +
tm_polygons(c("HPI", "gdp_cap_est"),
style=c("pretty", "kmeans"),
palette=list("RdYlGn", "Purples"),
auto.palette.mapping=FALSE,
title=c("Happy Planet Index", "GDP per capita")) +
tm_format_Europe() +
tm_style_grey()
tm_shape(metro) +
tm_bubbles(size=c("pop1970", "pop2020"), title.size="Population") +
tm_facets(free.scales=FALSE) +
tm_layout(panel.labels=c("1970", "2020"))
tm_shape(Europe) +
tm_polygons("well_being", title="Well-Being Index") +
tm_facets("part") +
tm_style_grey()
tm_shape(Europe[Europe$continent=="Europe",]) +
tm_fill("part", legend.show = FALSE) +
tm_facets("name", free.coords=TRUE, drop.units=TRUE)
train_url <- "http://s3.amazonaws.com/assets.datacamp.com/course/Kaggle/train.csv"
train <-
test_url <- "http://s3.amazonaws.com/assets.datacamp.com/course/Kaggle/test.csv"
train <- read.csv(train_url)
# Import the testing set: test
test_url <- "http://s3.amazonaws.com/assets.datacamp.com/course/Kaggle/test.csv"
test <- read.csv(test_url)
print(train)
print(test)
str(train)
str(test)
str(train)
table(train$Survived)
prop.table(table(train$Survived))
table(train$Sex, train$Survived)
table(train$survived)
table(train$Survived)
prop.table(train$Survived)
prop.table(train$Survived)
table(train$Survived)
prop.table(train$Survived,margin = 2)
prop.table(train$Survived,margin = 1)
prop.table(table(train$Survived))
table(train$Sex, train$Survived)
prop.table(table(train$Sex, train$Survived))
prop.table(table(train$Sex, train$Survived),margin = 1)
prop.table(table(train$Sex, train$Survived),margin = 2)
prop.table(table(train$Sex, train$Survived),margin = 1)
train$Child <- NA
train$Child <- NA
train$Child[train$Age < 18] <- 0
train$Child[train$Age >= 18] <- 1
table(train$Age)
table(train$Survived, train$Age)
table(train$Survived, train$Child)
prop.table(table(train$Survived, train$Child),1)
prop.table(table(train$Child, train$Survived),1)
prop.table(table(train$Child, train$Survived),1)
?rpartg
?rpart
library(rpart)
# Your train and test set are still loaded in
str(train)
str(test)
# method: Type of prediction you want. We want to predict a categorical variable, so classification: method = "class"
# Build the decision tree
my_tree_two <- rpart(Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked,
data = train, method = "class")
# Visualize the decision tree using plot() and text()
plot(my_tree_two)
text(my_tree_two)
plot(my_tree_two)
text(my_tree_two)
library(rattle)
fancyRpartPlot(my_tree_two)
train
str(train)
?rpart
library(rpart.plot)
library(RColorBrewer)
install.packages("rpart.plot")
# Kaggle R Tutorial on Machine Learning
# Import the training set: train
train_url <- "http://s3.amazonaws.com/assets.datacamp.com/course/Kaggle/train.csv"
train <- read.csv(train_url)
# Import the testing set: test
test_url <- "http://s3.amazonaws.com/assets.datacamp.com/course/Kaggle/test.csv"
test <- read.csv(test_url)
# Print train and test to the console
print(train)
print(test)
str(train)
str(test)
# absolute numbers
table(train$Survived)
# proportions
prop.table(table(train$Survived))
table(train$Sex, train$Survived)
# Survival rates in absolute numbers
table(train$Survived)
# Survival rates in proportions
prop.table(table(train$Survived))
# Two-way comparison: Sex and Survived
table(train$Sex, train$Survived)
# Two-way comparison: row-wise proportions
prop.table(table(train$Sex, train$Survived),margin = 1)
# Create the column child, and indicate whether child or no child
train$Child <- NA
train$Child[train$Age < 18] <- 1
train$Child[train$Age >= 18] <- 0
# Two-way comparison
prop.table(table(train$Child, train$Survived),1)
# Copy of test
test_one <- test
# Initialize a Survived column to 0
test_one$Survived =0
# Set Survived to 1 if Sex equals "female"
test_one$Survived[test$Sex =='female']=1
# Copy of test
test_one <- test
####### PART 2 - FROM ICEBERGS TO TREES
library(rpart)
# Your train and test set are still loaded in
str(train)
str(test)
# method: Type of prediction you want. We want to predict a categorical variable, so classification: method = "class"
# Build the decision tree
my_tree_two <- rpart(Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked,
data = train, method = "class")
# Visualize the decision tree using plot() and text()
plot(my_tree_two)
text(my_tree_two)
# Load in the packages to build a fancy plot
library(rattle)
library(rattle)
library(rpart.plot)
library(RColorBrewer)
# Time to plot your fancy tree
fancyRpartPlot(my_tree_two)
